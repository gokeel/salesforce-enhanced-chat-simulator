"""
Conversation History Module

This module handles sending chatbot conversation history to Salesforce Enhanced Chat
using JWT authentication and the Interaction Service API.
"""

import uuid
import time
import json
import requests
import jwt
from datetime import datetime, timedelta


def generate_oauth_token(jwt_config):
    """
    Generate access token using JWT for Interaction Service API
    
    Args:
        jwt_config: Dictionary with token_url, consumer_key, username, audience, private_key_path
        
    Returns:
        dict: Response with success status and token data
    """
    try:
        # Read private key
        with open(jwt_config['private_key_path'], 'r') as key_file:
            private_key = key_file.read()
        
        # Generate JWT claims
        now = datetime.utcnow()
        iat_time = int(now.timestamp())
        exp_time = now + timedelta(minutes=3)  # Shorter expiry time
        exp_timestamp = int(exp_time.timestamp())
        
        # For sandbox, use test.salesforce.com as audience
        audience = jwt_config['audience']
        # if 'sandbox' in audience:
        #     audience = 'https://test.salesforce.com'
        
        payload = {
            'iss': jwt_config['consumer_key'],  # Consumer key from connected app
            'sub': jwt_config['username'],  # Salesforce username
            'aud': audience,  # Login URL (test.salesforce.com for sandbox)
            # 'iat': iat_time,  # Issued at time
            'exp': exp_timestamp  # Expiration time
        }
        
        print(f"JWT Payload: {payload}")
        print(f"IAT: {now}, EXP: {exp_time}")
        
        # Generate signed JWT with RS256
        signed_jwt = jwt.encode(
            payload,
            private_key,
            algorithm='RS256'
        )
        
        print(f"Signed JWT: {signed_jwt[:100]}...")
        
        # Exchange JWT for access token
        data = {
            'grant_type': 'urn:ietf:params:oauth:grant-type:jwt-bearer',
            'assertion': signed_jwt
        }
        
        headers = {
            'Content-Type': 'application/x-www-form-urlencoded'
        }
        
        print(f"Requesting access token from: {jwt_config['token_url']}")
        
        response = requests.post(jwt_config['token_url'], data=data, headers=headers)
        
        print(f"Token Response Status: {response.status_code}")
        print(f"Token Response Body: {response.text}")
        
        if response.status_code == 200:
            token_data = response.json()
            return {
                'success': True,
                'access_token': token_data.get('access_token'),
                'token_type': token_data.get('token_type', 'Bearer'),
                'instance_url': token_data.get('instance_url'),
                'scope': token_data.get('scope', '')
            }
        else:
            return {
                'success': False,
                'error': f'JWT token exchange failed with status {response.status_code}',
                'details': response.text
            }, response.status_code
            
    except Exception as e:
        return {
            'success': False,
            'error': str(e)
        }, 500


def transform_conversation_to_salesforce_format(data, scrt_url, org_id, es_developer_name, app_state):
    """
    Transform simple conversation format to Salesforce API format
    
    Args:
        data: Conversation data with participants and messages
        scrt_url: Salesforce SCRT URL
        org_id: Organization ID
        es_developer_name: ES Developer Name
        app_state: Application state dict
        
    Returns:
        tuple: (payload dict, error message or None)
    """
    try:
        # Get channel address
        channel_address = app_state.get("channel_address_identifier") or app_state.get("conversation_id", "").lower()
        
        # Build participants
        participants_data = data.get("participants", [])
        conversation_participants = []
        for p in participants_data:
            conversation_participants.append({
                "displayName": p.get("displayName", "Unknown"),
                "participant": {
                    "subject": p.get("subject", ""),
                    "role": p.get("role", "EndUser"),
                    "appType": p.get("appType", "custom")
                },
                "joinedTime": str(data.get("conversationInfo", {}).get("startTime", int(time.time() * 1000)))
            })
        
        # Build conversation entries (reverse order - newest first)
        messages = data.get("messages", [])
        conversation_entries = []
        
        # Take only first 5 messages (API limit)
        messages_to_send = messages[:5]
        
        # Reverse order for API (newest first)
        messages_to_send.reverse()
        
        for msg in messages_to_send:
            # Determine sender
            sender_role = "EndUser"
            sender_subject = ""
            
            if msg.get("sender") == "bot":
                sender_role = "Chatbot"
                # Find chatbot participant
                for p in participants_data:
                    if p.get("role") == "Chatbot":
                        sender_subject = p.get("subject", "")
                        break
            else:
                # Find user participant
                for p in participants_data:
                    if p.get("role") == "EndUser":
                        sender_subject = p.get("subject", "")
                        break
            
            # Generate unique message ID
            msg_id = str(uuid.uuid4())
            
            entry = {
                "clientTimestamp": str(msg.get("timestamp", int(time.time() * 1000))),
                "entryPayload": {
                    "entryType": "Message",
                    "id": msg_id,
                    "abstractMessage": {
                        "messageType": "StaticContentMessage",
                        "id": msg_id,
                        "staticContent": {
                            "formatType": "Text",
                            "text": msg.get("text", "")
                        }
                    }
                },
                "sender": {
                    "subject": sender_subject,
                    "role": sender_role,
                    "appType": "custom"
                }
            }
            conversation_entries.append(entry)
        
        # Build messaging session
        start_time = data.get("conversationInfo", {}).get("startTime", int(time.time() * 1000))
        messaging_session = {
            "messagingSessionRequestType": "EstablishMessagingSession",
            "payload": {
                "startTime": str(start_time)
            }
        }
        
        # Build final payload
        payload = {
            "channelAddressIdentifier": channel_address,
            "conversationParticipants": conversation_participants,
            "conversationEntries": conversation_entries,
            "messagingSession": messaging_session
        }
        
        return payload, None
        
    except Exception as e:
        return None, str(e)


def send_history_to_salesforce(payload, access_token, scrt_url, org_id, es_developer_name):
    """
    Send conversation history to Salesforce API
    
    Args:
        payload: Formatted conversation history payload
        access_token: OAuth or JWT access token
        scrt_url: Salesforce SCRT URL
        org_id: Organization ID
        es_developer_name: ES Developer Name
        
    Returns:
        tuple: (success bool, response data dict, status code)
    """
    try:
        # Generate unique request ID
        request_id = str(uuid.uuid4())
        
        # Call Salesforce API
        url = f"{scrt_url}/iamessage/api/v1/conversationHistory"
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {access_token}",
            "OrgId": org_id,
            "AuthorizationContext": es_developer_name,
            "AuthorizationContextType": "ConversationChannelDefinition",
            "RequestId": request_id
        }
        
        print(f"Calling Salesforce API: {url}")
        print(f"Headers: {headers}")
        print(f"Payload: {json.dumps(payload, indent=2)}")
        
        response = requests.post(url, json=payload, headers=headers)
        
        print(f"Response Status: {response.status_code}")
        print(f"Response Body: {response.text}")
        
        if response.status_code in [200, 201]:
            response_data = response.json()
            return True, {
                "success": True,
                "messagingSessionId": response_data.get("messagingSessionId"),
                "message": f"Successfully sent {len(payload['conversationEntries'])} conversation entries",
                "entriesSent": len(payload['conversationEntries']),
                "response": response_data
            }, 200
        else:
            return False, {
                "success": False,
                "error": f"API returned status {response.status_code}",
                "details": response.text
            }, response.status_code
            
    except Exception as e:
        return False, {
            "success": False,
            "error": str(e)
        }, 500


def handle_send_conversation_history(request_obj, app_state, scrt_url, org_id, es_developer_name):
    """
    Main handler for sending conversation history
    Combines JWT token checking, data transformation, and API call
    
    Args:
        request_obj: Flask request object
        app_state: Application state dict
        scrt_url: Salesforce SCRT URL
        org_id: Organization ID
        es_developer_name: ES Developer Name
        
    Returns:
        tuple: (response dict, status code)
    """
    # Check for JWT access token in custom header (from history page)
    jwt_token = request_obj.headers.get('X-OAuth-Token')
    
    # Fallback to app_state token if no JWT token provided (backward compatibility)
    if not jwt_token:
        if not app_state.get("access_token"):
            return {
                "success": False,
                "error": "No access token available. Please generate access token first."
            }, 400
        access_token = app_state["access_token"]
    else:
        access_token = jwt_token
    
    # For conversation ID, we can make it optional when using JWT
    conversation_id = app_state.get("conversation_id")
    if not conversation_id and not jwt_token:
        return {
            "success": False,
            "error": "No conversation available. Please create a conversation first."
        }, 400
    
    # Get request data
    data = request_obj.get_json()
    if not data:
        return {
            "success": False,
            "error": "No conversation history data provided"
        }, 400
    
    # Transform data to Salesforce format
    payload, error = transform_conversation_to_salesforce_format(
        data, scrt_url, org_id, es_developer_name, app_state
    )
    
    if error:
        return {
            "success": False,
            "error": f"Failed to transform data: {error}"
        }, 400
    
    # Send to Salesforce
    success, response_data, status_code = send_history_to_salesforce(
        payload, access_token, scrt_url, org_id, es_developer_name
    )
    
    return response_data, status_code
